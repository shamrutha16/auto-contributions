
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ðŸš€ Generated by GitMaxer (Free Plan)
# ðŸ”— Upgrade at https://gitmaxer.vercel.app for watermark-free code
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

=begin
Learning Objective:
This tutorial will guide you through building a simple Ruby script that translates common English phrases into their corresponding emoji representations. We will focus on using a Hash data structure to store our phrase-to-emoji mappings and then iterate through the input string to perform the translation. This will help you understand:
1. How to define and use Hashes in Ruby for key-value storage.
2. How to iterate over strings and perform conditional logic.
3. How to build a simple translation mechanism.
=end

# Define a Hash called 'emoji_map' to store our phrase-to-emoji translations.
# A Hash is perfect for this because it allows us to associate specific
# English phrases (keys) with their emoji counterparts (values).
# This makes lookups very efficient.
emoji_map = {
  "hello" => "ðŸ‘‹",
  "goodbye" => "ðŸ‘‹",
  "love" => "â¤ï¸",
  "happy" => "ðŸ˜Š",
  "sad" => "ðŸ˜ž",
  "great" => "ðŸ‘",
  "bad" => "ðŸ‘Ž",
  "yes" => "âœ…",
  "no" => "âŒ",
  "thank you" => "ðŸ™",
  "wow" => "ðŸ˜²",
  "food" => "ðŸ”",
  "drink" => "â˜•",
  "party" => "ðŸŽ‰",
  "star" => "â­",
  "sun" => "â˜€ï¸",
  "moon" => "ðŸŒ™",
  "fire" => "ðŸ”¥",
  "water" => "ðŸ’§",
  "tree" => "ðŸŒ³",
  "house" => "ðŸ ",
  "car" => "ðŸš—",
  "money" => "ðŸ’°",
  "time" => "â°",
  "cool" => "ðŸ˜Ž",
  "idea" => "ðŸ’¡",
  "sleep" => "ðŸ˜´",
  "run" => "ðŸƒ",
  "walk" => "ðŸš¶",
  "music" => "ðŸŽ¶",
  "movie" => "ðŸŽ¬",
  "book" => "ðŸ“š",
  "computer" => "ðŸ’»",
  "phone" => "ðŸ“±",
  "world" => "ðŸŒ",
  "heart" => "â¤ï¸", # Another way to represent love
  "smile" => "ðŸ˜„"
}

# Define a function called 'translate_to_emoji' that takes a string of text as input.
# This function will perform the core translation logic.
def translate_to_emoji(text, mapping)
  # Convert the input text to lowercase. This ensures that our translations
  # are case-insensitive. For example, "Hello" will be translated the same
  # as "hello".
  processed_text = text.downcase

  # Initialize an empty array to store the translated words or phrases.
  # We'll build our emoji-rich output here.
  translated_parts = []

  # We need to process the text word by word or by potential phrases.
  # A simple approach is to split the text into words and then try to
  # match multi-word phrases first.

  # To handle multi-word phrases like "thank you" or "goodbye", we'll iterate
  # through the mapping and see if any of its keys are present in the text.
  # We sort the keys by length in descending order. This is crucial!
  # If we checked "you" before "thank you", "thank you" would be broken into
  # "thank" and "you", and we might miss the "thank you" translation.
  sorted_keys = mapping.keys.sort_by(&:length).reverse

  # Keep track of the current position in the processed text.
  current_index = 0

  # Loop through the sorted keys (phrases and words).
  while current_index < processed_text.length
    found_match = false # Flag to indicate if we found a translation in this iteration.

    # Iterate through each potential phrase (key) from our emoji_map.
    sorted_keys.each do |phrase|
      # Check if the current phrase exists in the processed text starting from
      # our current_index.
      # We use `processed_text[current_index, phrase.length]` to get a substring
      # of the same length as the phrase starting from current_index.
      # We also add a space after the phrase in the text to ensure we match whole words
      # or phrases, not just substrings within words (e.g., "hell" in "hello").
      # We need to handle the case where the phrase is at the very end of the text,
      # so we check if `processed_text[current_index + phrase.length]` is a space or nil.
      if processed_text[current_index..-1].start_with?(phrase) &&
         (processed_text[current_index + phrase.length].nil? || processed_text[current_index + phrase.length] == ' ')

        # If a match is found, add its corresponding emoji to our results.
        translated_parts << mapping[phrase]
        # Advance our current_index past the matched phrase and any trailing space.
        current_index += phrase.length
        # If the character immediately after the phrase is a space, skip that space too.
        current_index += 1 if processed_text[current_index] == ' '
        found_match = true # We found a match, so break out of this inner loop.
        break
      end
    end

    # If no phrase from our map matched at the current_index, it means this
    # part of the text is not translatable by our current map.
    if !found_match
      # We need to find the next space to isolate the current word.
      # This prevents us from consuming the whole remaining string if there's no match.
      space_index = processed_text.index(' ', current_index)

      # If there's no more space, it means this is the last word (or the only word).
      if space_index.nil?
        # Extract the remaining part of the string.
        current_word = processed_text[current_index..-1]
        # Add the untranslated word (as is) to our results.
        translated_parts << current_word
        # Move the index to the end of the string to exit the loop.
        current_index = processed_text.length
      else
        # Extract the word before the next space.
        current_word = processed_text[current_index...space_index]
        # Add the untranslated word to our results.
        translated_parts << current_word
        # Advance our current_index to the position after the space.
        current_index = space_index + 1
      end
    end
  end

  # Join all the translated parts back together with spaces to form the final
  # translated string.
  translated_parts.join(' ')
end

# --- Example Usage ---

puts "Welcome to the Ruby Emoji Translator!"
puts "------------------------------------"
puts "Enter some text, and I'll try to translate it into emojis."
puts "Type 'quit' to exit."
puts "------------------------------------"

# Start an infinite loop that will continue until the user types 'quit'.
loop do
  print "> " # Display a prompt for user input.
  user_input = gets.chomp # Read the user's input and remove any trailing newline character.

  # Check if the user wants to quit.
  if user_input.downcase == 'quit'
    puts "Goodbye! ðŸ‘‹" # Say goodbye with an emoji.
    break # Exit the loop.
  end

  # Call our translation function and store the result.
  translated_output = translate_to_emoji(user_input, emoji_map)

  # Display the translated output to the user.
  puts "Translation: #{translated_output}"
  puts "------------------------------------"
end

# Example of how you could call the function directly without user input:
# puts translate_to_emoji("Hello, I love you and you are great!", emoji_map)
# => ðŸ‘‹, I â¤ï¸ you and you are ðŸ‘!
# puts translate_to_emoji("This is bad. Wow!", emoji_map)
# => This is ðŸ‘Ž. ðŸ˜²!
# puts translate_to_emoji("Thank you for the food and drink.", emoji_map)
# => ðŸ™ for the ðŸ” and â˜•.
# puts translate_to_emoji("The sun is bright and the tree is green.", emoji_map)
# => The â˜€ï¸ is bright and the ðŸŒ³ is green.
# puts translate_to_emoji("Goodnight moon.", emoji_map)
# => Goodnight ðŸŒ™.
=